\documentclass{article}
\usepackage{mathtools}
\usepackage{listings}
\lstset{language=Java,
    numbers=left,
    basicstyle=\ttfamily,
    showstringspaces=false
}
    
\begin{document}
\title{CS320 Homework 2}
\author{Dustin Randall}
\maketitle

\section{Use at least 3 levels of a recursion tree to solve \(T(n) = 4T(\frac{n}{2}) + n^2\).}
We'll start by expanding the first few levels of the recursive tree.
\begin{align*}
    T(n) &= 4T(\frac{n}{2}) + n^2 \\
    T(\frac{n}{2}) &= 4T(\frac{n}{4}) + (\frac{n}{2})^2 \\
    T(\frac{n}{4}) &= 4T(\frac{n}{8}) + (\frac{n}{4})^2 \\
    T(\frac{n}{8}) &= 4T(\frac{n}{16}) + (\frac{n}{8})^2 \\
    \vdots \\
    T(1) &= 1
\end{align*}

Using these expansions, let's substitute back into the original equation:
\begin{align*}
    T(n) &= 4T(\frac{n}{2}) + n^2 \\
         &= 4T(\frac{n}{4}) + (\frac{n}{2})^2 + 4T(\frac{n}{4}) + (\frac{n}{2})^2 + 4T(\frac{n}{4}) + (\frac{n}{2})^2 + 4T(\frac{n}{4}) + (\frac{n}{2})^2 + n^2 \\
         &= 4T(\frac{n}{4}) + 4T(\frac{n}{4}) + 4T(\frac{n}{4}) + 4T(\frac{n}{4}) + 4(\frac{n}{2})^2 + n^2 \\
         &= 4T(\frac{n}{4}) + 4T(\frac{n}{4}) + 4T(\frac{n}{4}) + 4T(\frac{n}{4}) + 4(\frac{n}{2})^2 + n^2 \\
         &= 16T(\frac{n}{4}) + 4(\frac{n^2}{4}) + n^2 \\
         &= 16T(\frac{n}{4}) + n^2 + n^2
\end{align*}
Continuing with one more expansion
\begin{align*}
    T(n) &= 16T(\frac{n}{4}) + n^2 + n^2 \\
         &= 4T(\frac{n}{8}) + (\frac{n}{4})^2 + \dots \text(16 times) + n^2 + n^2 \\
         &= 4T(\frac{n}{8}) + \dots \text(16 times) + 16(\frac{n}{4})^2 + 2n^2 \\
         &= 64T(\frac{n}{8}) + 16(\frac{n^2}{16}) + 2n^2 \\
         &= 64T(\frac{n}{8}) + n^2 + 2n^2 \\
         &= 64T(\frac{n}{8}) + 3n^2
\end{align*}
While we could expand another level, we can see a pattern emerging, and the next level would work out to \\
\(128T(\frac{n}{16}) + 4n^2\) \\
From here, we can see that each level adds another \(n^2\) to the total, and we know that T(1) = 1.
Given that each level divides n by 2, we know that there are \(\log_2(n) + 1\) levels.
So the runtime ends up being \(\log_2(n)n^2\) or more simply \(n^2 \log(n)\).

\section{Use inductive proof to show \(T(n) = 5T(\frac{n}{4}) + n^2 = O(n^2)\).}
Let's first expand what \(O(n^2)\) means.
There exists some constant \(c > 0\) and \(n_0 > 0\) such that for all \(n \geq n_0\), \(T(n) \leq cn^2\).
So we need to find values for \(c\) and \(n_0\) where we can satisfy the inequality. \\
Base Case: \\
Let \(n_0 = 4\) and \(c = 100\)
\begin{align*}
    T(4) & \leq cn^2 \\
    5(\frac{4}{4}) + 4^2 &\leq 100(4^2) \\
    5(1) + 16 &\leq 100(16)\\
    21 &\leq 1600 
\end{align*}

We now have the assumption that \(T(k) \leq ck^2\) for all \(k \geq n_0\).
We need to show that \(T(k+1) \leq c(k+1)^2\).
\begin{align*}
    T(k+1) &= 5T(\frac{k+1}{4}) + (k+1)^2 \\
           &\leq 5c(\frac{k+1}{4})^2 + (k+1)^2 \\
              &= 5c(\frac{(k+1)^2}{16}) + (k+1)^2 \\
              &= 5*100(\frac{(k+1)^2}{16}) + (k+1)^2 \\
              &= \frac{500}{16}(k+1)^2 + (k+1)^2 \\
              &= \frac{516}{16}(k+1)^2 \\
              &= 32.25(k+1)^2 \\
            32.25(k+1)^2 &\leq 100(k+1)^2
\end{align*}
Because we have demonstrated that our base case holds, and that our inductive step holds
we have proven that \(T(n) = 5T(\frac{n}{4}) + n^2 = O(n^2)\).

\section{Solve the following using the Master Theorem.}
    \subsection{\(T(n) = 25T(\frac{n}{5}) + n^2 + \log(n)\)}
    \subsection{\(T(n) = 25T(\frac{n}{5}) + 2n^3 + n \log(n)\)}
    \subsection{\(T(n) = 25T(\frac{n}{5}) + 3n^4 - 3n^2\)}
    \subsection{\(T(n) = 125T(\frac{n}{5}) + 4n^2 + 5n \log(n)\)}
    \subsection{\(T(n) = 125T(\frac{n}{5}) + 5n^3 + 2n^2\)}

\section{Given the root node of a BST, convert into a double linked list where left is the previous, and right is the next.}
The general approach to this problem is to do an in-order traversal of the tree.
After visiting a node, it's prev pointer needs to be the right-most node of the left subtree.
Similarly, the node's next pointer needs to be the left-most node of the right subtree.
Doing this recursively means I will need to return both the left and right most nodes.
\begin{lstlisting}
BeginEnd Link(Node root) {
  if(root == null) return null;
  Node begin = root;
  Node end = root;
  if(root.Left != null) {
    BeginEnd left = Link(root.Left);

    //update the left most of this subtree
    begin = left.Begin; 

    //set the prev pointer for root
    root.Left = left.End; 

    //set next pointer for the right-most element of left subtree
    left.End.Right = root; 
  }
  if(root.Right != null) {
    BeginEnd right = Link(root.Right);

    //update the right most of this subtree
    end = right.End;

    //set the next pointer for root
    root.Right = right.Begin;

    //set prev pointer for the left-most element of right subtree
    right.Begin.Left = root;
  }
  return new BeginEnd(begin, end);
}
\end{lstlisting}
The time complexity of this algorithm must be at least \(O(n)\) because each element must be touched at least once.
There are no loops in the code, and so the time complexity can be described with the recurrence \(T(n) = 2T(\frac{n}{2}) + \Theta(c)\).

\section{Compare and contrast hash tables and binary search trees.}

\end{document}